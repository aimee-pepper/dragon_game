<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dragon Spine Placement Tool</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #1e1a16;
      color: #d4cdc4;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 12px;
      overflow-x: hidden;
    }
    h1 { text-align: center; margin-bottom: 4px; color: #c4a265; font-size: 20px; }
    .subtitle { text-align: center; color: #8a7e72; margin-bottom: 12px; font-size: 13px; }

    .toolbar-row {
      display: flex; gap: 8px; align-items: center; justify-content: center;
      flex-wrap: wrap; margin-bottom: 8px; padding: 6px 8px;
      background: #2a2420; border-radius: 8px; border: 1px solid #3d3530;
    }
    .toolbar-row label { font-size: 12px; color: #8a7e72; }
    .toolbar-row select, .toolbar-row input[type="number"] {
      background: #1e1a16; color: #d4cdc4; border: 1px solid #3d3530;
      border-radius: 4px; padding: 4px 8px; font-size: 12px;
    }
    .toolbar-row select { min-width: 100px; }
    button {
      background: #c4a265; color: #1e1a16; border: none;
      padding: 6px 14px; border-radius: 6px; cursor: pointer;
      font-weight: bold; font-size: 12px; white-space: nowrap;
    }
    button:hover { background: #d4b275; }
    button.secondary { background: #3d3530; color: #d4cdc4; }
    button.secondary:hover { background: #4d4540; }
    button.danger { background: #884444; color: #f0e0e0; }
    button.danger:hover { background: #aa5555; }
    .sep { width: 1px; height: 24px; background: #3d3530; }
    .tab-btn {
      padding: 4px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;
      background: #3d3530; color: #d4cdc4; border: 1px solid #3d3530;
    }
    .tab-btn.active { background: #c4a265; color: #1e1a16; border-color: #c4a265; }
    .tab-btn.green.active { background: #5a8a4a; color: #fff; border-color: #5a8a4a; }
    .tab-btn.purple.active { background: #7a5a9a; color: #fff; border-color: #7a5a9a; }
    .tab-btn.blue.active { background: #4a6a9a; color: #fff; border-color: #4a6a9a; }

    .main-layout {
      display: flex; gap: 12px; height: calc(100vh - 210px); min-height: 500px;
    }

    /* Canvas area */
    .canvas-container {
      flex: 1; position: relative; overflow: hidden;
      background: repeating-conic-gradient(#1a1a1a 0% 25%, #222 0% 50%) 50% / 20px 20px;
      border: 2px solid #3d3530; border-radius: 8px;
    }
    #mainCanvas {
      position: absolute; top: 0; left: 0;
      transform-origin: 0 0; cursor: crosshair;
    }
    #mainCanvas.dragging { cursor: grabbing; }
    .zoom-indicator {
      position: absolute; bottom: 8px; right: 8px;
      background: rgba(30,26,22,0.85); color: #8a7e72;
      padding: 3px 8px; border-radius: 4px; font-size: 11px;
      pointer-events: none;
    }

    /* Side panel */
    .side-panel {
      width: 340px; min-width: 300px;
      display: flex; flex-direction: column; gap: 6px;
    }
    .panel-section {
      background: #2a2420; border: 1px solid #3d3530; border-radius: 8px;
      padding: 8px;
    }
    .panel-section h3 {
      font-size: 12px; color: #c4a265; margin-bottom: 6px;
      text-transform: uppercase; letter-spacing: 1px;
    }
    .slider-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
    }
    .slider-row label { font-size: 11px; color: #8a7e72; min-width: 80px; }
    .slider-row input[type="range"] {
      flex: 1; accent-color: #c4a265; height: 4px;
    }
    .slider-row .val {
      font-size: 11px; color: #d4cdc4; min-width: 36px; text-align: right;
      font-family: monospace;
    }

    .spine-list {
      flex: 1; overflow-y: auto; min-height: 100px; max-height: 250px;
    }
    .spine-item {
      display: flex; align-items: center; gap: 6px;
      padding: 4px 6px; border-radius: 6px; cursor: pointer;
      font-size: 11px; border: 1px solid transparent;
    }
    .spine-item:hover { background: #3d3530; }
    .spine-item.selected { background: #3d3530; border-color: #c4a265; }
    .spine-item .idx { color: #8a7e72; min-width: 20px; }
    .spine-item .info { flex: 1; color: #d4cdc4; }
    .spine-item .angle { color: #8a7e72; font-family: monospace; font-size: 10px; }

    .override-row {
      display: flex; align-items: center; gap: 6px; margin-top: 4px;
    }
    .override-row label { font-size: 11px; color: #8a7e72; min-width: 60px; }
    .override-row input {
      width: 60px; background: #1e1a16; color: #d4cdc4; border: 1px solid #3d3530;
      border-radius: 4px; padding: 3px 6px; font-size: 11px; font-family: monospace;
    }

    .output-box {
      background: #1e1a16; border: 1px solid #3d3530; border-radius: 8px;
      padding: 8px; max-height: 200px; overflow-y: auto;
    }
    .output-box pre {
      font-size: 10px; color: #8a7e72; white-space: pre-wrap;
      word-break: break-all; font-family: 'Courier New', monospace;
    }

    .instructions {
      font-size: 11px; color: #6a5a4a; line-height: 1.5;
      padding: 4px 0;
    }
    .instructions kbd {
      background: #3d3530; padding: 1px 5px; border-radius: 3px;
      font-size: 10px; color: #d4cdc4;
    }
  </style>
</head>
<body>
  <h1>Spine Placement Tool</h1>
  <p class="subtitle">Draw a spine path along the dragon's back/tail, distribute spine sprites along it</p>

  <!-- Toolbar Row 1: Body + Tail selection -->
  <div class="toolbar-row">
    <label>Body:</label>
    <div class="tab-btn green active" data-body="standard">Standard</div>
    <div class="tab-btn green" data-body="sinuous">Sinuous</div>
    <div class="tab-btn green" data-body="bulky">Bulky</div>
    <span class="sep"></span>
    <label>Tail:</label>
    <div class="tab-btn purple active" data-tail="normal">Normal</div>
    <div class="tab-btn purple" data-tail="whip">Whip</div>
    <div class="tab-btn purple" data-tail="heavy">Heavy</div>
    <span class="sep"></span>
    <label>Length:</label>
    <div class="tab-btn blue active" data-length="medium">Med</div>
    <div class="tab-btn blue" data-length="short">Short</div>
    <div class="tab-btn blue" data-length="long">Long</div>
  </div>

  <!-- Toolbar Row 2: Spine type + actions -->
  <div class="toolbar-row">
    <label>Spine:</label>
    <div class="tab-btn active" data-spine="ridge">Ridge</div>
    <div class="tab-btn" data-spine="spike">Spike</div>
    <div class="tab-btn" data-spine="sail">Sail</div>
    <span class="sep"></span>
    <label>Height:</label>
    <div class="tab-btn active" data-height="medium">Med</div>
    <div class="tab-btn" data-height="low">Low</div>
    <div class="tab-btn" data-height="tall">Tall</div>
    <span class="sep"></span>
    <button id="btn-clear-path" class="danger">Clear Path</button>
    <button id="btn-save" class="secondary">Save</button>
    <button id="btn-copy-anchors">Copy Anchors</button>
    <button id="btn-copy-curve">Copy Curve</button>
  </div>

  <div class="main-layout">
    <!-- Canvas Area -->
    <div class="canvas-container" id="canvasContainer">
      <canvas id="mainCanvas"></canvas>
      <div class="zoom-indicator" id="zoomIndicator">100%</div>
    </div>

    <!-- Side Panel -->
    <div class="side-panel">
      <!-- Curve Controls -->
      <div class="panel-section">
        <h3>Curve Controls</h3>
        <div class="slider-row">
          <label>Spine Count</label>
          <input type="range" id="spine-count" min="2" max="60" value="10">
          <span class="val" id="spine-count-val">10</span>
        </div>
        <div class="slider-row">
          <label>Spacing</label>
          <input type="range" id="spine-spacing" min="0.5" max="2.0" step="0.05" value="1.0">
          <span class="val" id="spine-spacing-val">1.0</span>
        </div>
        <div class="slider-row">
          <label>Scale</label>
          <input type="range" id="spine-scale" min="0.3" max="2.0" step="0.05" value="1.0">
          <span class="val" id="spine-scale-val">1.0</span>
        </div>
        <div class="slider-row">
          <label>Height Offset</label>
          <input type="range" id="height-offset" min="1" max="400" step="1" value="60">
          <span class="val" id="height-offset-val">60</span>
        </div>
        <div class="slider-row">
          <label>Rotation</label>
          <input type="range" id="global-rotation" min="-180" max="180" step="1" value="0">
          <span class="val" id="global-rotation-val">0°</span>
        </div>
        <label style="font-size:11px; color:#8a7e72; display:flex; align-items:center; gap:4px; margin-top:2px; cursor:pointer;">
          <input type="checkbox" id="show-height-guide" checked style="accent-color:#c4a265;">
          Show height guide line
        </label>
        <div class="instructions">
          <kbd>Click</kbd> canvas to add points.
          <kbd>Drag</kbd> points to adjust.
          <kbd>Shift+Click</kbd> curve to insert point.
          <kbd>Alt+Click</kbd> curve to delete nearest point.
          <kbd>Right-click</kbd> point to delete.
          <kbd>Scroll</kbd> to zoom. <kbd>Space+drag</kbd> to pan.
          <br><span style="color:#aa77cc;">Purple line</span> = height envelope.
          <kbd>Click</kbd> line to add control point.
          <kbd>Drag</kbd> points ↕ to adjust scale.
          <kbd>Right-click</kbd> to remove.
        </div>
      </div>

      <!-- Height Envelope Points -->
      <div class="panel-section" style="flex:1;display:flex;flex-direction:column;">
        <h3>Envelope Points <span id="envelope-point-count" style="color:#8a7e72;font-weight:normal;">(2)</span></h3>
        <div class="spine-list" id="envelope-list"></div>
      </div>

      <!-- Output -->
      <div class="panel-section">
        <h3>Output</h3>
        <div class="output-box" id="output-box">
          <pre id="output-text">Draw a path to generate output...</pre>
        </div>
      </div>
    </div>
  </div>

<script type="module">
import {
  ANCHORS,
  SPRITE_WIDTH,
  SPRITE_HEIGHT,
} from './js/sprite-config.js';

// ── Constants ──
const ASSET_BASE = 'assets/sprites/';
const BODY_TYPES = ['standard', 'sinuous', 'bulky'];
const TAIL_STYLES = ['normal', 'whip', 'heavy'];
const TAIL_LENGTHS = ['short', 'medium', 'long'];
const SPINE_TYPES = ['ridge', 'spike', 'sail'];
const SPINE_HEIGHTS = ['low', 'medium', 'tall'];

// Repeating spine asset filenames per type and height
// Each entry is an array of filenames to layer (fill first, then outline)
const SPINE_FILENAMES = {
  spike: { low: ['spine_spike_S'], medium: ['spine_spike_M'], tall: ['spine_spike_L'] },
  sail:  { low: ['spine_sail_S_f', 'spine_sail_S_o'], medium: ['spine_sail_M_f', 'spine_sail_M_o'], tall: ['spine_sail_L_f', 'spine_sail_L_o'] },
  ridge: { low: ['spine_ridge_S_f', 'spine_ridge_S_o'], medium: ['spine_ridge_M_f', 'spine_ridge_M_o'], tall: ['spine_ridge_L_f', 'spine_ridge_L_o'] },
};

const BODY_FILENAMES = {
  standard: 'body_stan_mf',
  sinuous:  'body_sin_mf',
  bulky:    'body_bulk_mf',
};
const TAIL_FILENAMES = {
  normal: { short: 'tail_normal_s_f', medium: 'tail_normal_m_f', long: 'tail_normal_l_f' },
  whip:   { short: 'tail_whip_s_f',   medium: 'tail_whip_m_f',   long: 'tail_whip_l_f' },
  heavy:  { short: 'tail_heavy_s_f',  medium: 'tail_heavy_m_f',  long: 'tail_heavy_l_f' },
};

// Head spine filenames per type/height (same type/height as body spines)
const HEAD_SPINE_FILENAMES = {
  spike: { low: 'spinehead_spike_S', medium: 'spinehead_spike_M', tall: 'spinehead_spike_L' },
  sail:  { low: ['spinehead_sail_S_f', 'spinehead_sail_S_o'], medium: ['spinehead_sail_M_f', 'spinehead_sail_M_o'], tall: ['spinehead_sail_L_f', 'spinehead_sail_L_o'] },
  ridge: { low: ['spinehead_ridge_S_f', 'spinehead_ridge_S_o'], medium: ['spinehead_ridge_M_f', 'spinehead_ridge_M_o'], tall: ['spinehead_ridge_L_f', 'spinehead_ridge_L_o'] },
};

const HEAD_FILENAME = 'head_f';

const POINT_RADIUS = 8;
const CONTROL_POINT_COLOR = '#c4a265';
const CURVE_COLOR = '#c4a26580';
const SPINE_MARKER_COLOR = '#6a9f5b';
const ENDPOINT_COLOR_START = '#cc5555';
const ENDPOINT_COLOR_END = '#5588cc';

const STORAGE_KEY = 'dragon-spine-paths-v1';

// ── State ──
let currentBody = 'standard';
let currentTail = 'normal';
let currentLength = 'medium';
let currentSpine = 'ridge';
let currentHeight = 'medium';

let controlPoints = [];   // Array of { x, y } in sprite-space coordinates
let spineCount = 10;
let spineSpacing = 1.0;
let spineScale = 1.0;
let globalRotation = 0;    // degrees added to ALL spine angles
let perSpineOverrides = {}; // legacy — kept for backwards compat with saved data

// Height guide — an independent envelope curve controlling per-spine scale and rotation
// Each height control point has:
//   t   — position along main curve (0-1)
//   mul — scale multiplier (1.0 = normal, 0 = zero, 2.0 = double)
//   rot — additional rotation offset in degrees (0 = no extra rotation)
// Spines linearly interpolate between adjacent control points.
let heightControlPoints = [{ t: 0, mul: 1.0, rot: 0, wid: 1.0 }, { t: 1, mul: 1.0, rot: 0, wid: 1.0 }];
let heightOffset = 60;       // Visual distance from main curve at mul=1.0 (sprite-space px)
let showHeightGuide = true;
let isDraggingHeightCP = -1; // index of height control point being dragged
let isDraggingHeightGuide = false;   // dragging the line itself (global offset)
let heightGuideStartY = 0;
let heightGuideStartOffset = 0;

// Pan / Zoom
let zoom = 0.3;
let panX = 0;
let panY = 0;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let isDraggingPoint = -1;
let spaceHeld = false;

// Cached images
const imageCache = new Map();

// ── DOM refs ──
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');
const zoomIndicator = document.getElementById('zoomIndicator');
const spineCountSlider = document.getElementById('spine-count');
const spineCountVal = document.getElementById('spine-count-val');
const spineSpacingSlider = document.getElementById('spine-spacing');
const spineSpacingVal = document.getElementById('spine-spacing-val');
const spineScaleSlider = document.getElementById('spine-scale');
const spineScaleVal = document.getElementById('spine-scale-val');
const globalRotSlider = document.getElementById('global-rotation');
const globalRotVal = document.getElementById('global-rotation-val');
const envelopeListEl = document.getElementById('envelope-list');
const envelopePointCount = document.getElementById('envelope-point-count');
const outputText = document.getElementById('output-text');
const heightOffsetSlider = document.getElementById('height-offset');
const heightOffsetVal = document.getElementById('height-offset-val');
const showHeightGuideCheckbox = document.getElementById('show-height-guide');

// ── Canvas Setup ──
canvas.width = SPRITE_WIDTH;
canvas.height = SPRITE_HEIGHT;

function updateCanvasTransform() {
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
  zoomIndicator.textContent = `${Math.round(zoom * 100)}%`;
}
updateCanvasTransform();

// ── Image Loading ──
function loadImage(filename) {
  const key = filename + '.png';
  if (imageCache.has(key)) return Promise.resolve(imageCache.get(key));
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { imageCache.set(key, img); resolve(img); };
    img.onerror = () => resolve(null);
    img.src = ASSET_BASE + key;
  });
}

function getAnchor(filename, bodyType) {
  const keyed = ANCHORS[`${filename}:${bodyType}`];
  if (keyed) return keyed;
  return ANCHORS[filename] || { x: 0, y: 0 };
}

// ── Bézier Math ──
// Evaluate a Catmull-Rom spline through the control points at parameter t ∈ [0, 1]
// This gives a smooth curve that passes through ALL control points.
function catmullRomPoint(points, t) {
  if (points.length < 2) return points[0] || { x: 0, y: 0 };
  if (points.length === 2) {
    return {
      x: points[0].x + (points[1].x - points[0].x) * t,
      y: points[0].y + (points[1].y - points[0].y) * t,
    };
  }

  const n = points.length - 1;
  const segment = Math.min(Math.floor(t * n), n - 1);
  const localT = t * n - segment;

  // Get 4 points for this segment (with endpoint mirroring)
  const p0 = points[Math.max(0, segment - 1)];
  const p1 = points[segment];
  const p2 = points[Math.min(n, segment + 1)];
  const p3 = points[Math.min(n, segment + 2)];

  const tt = localT * localT;
  const ttt = tt * localT;

  return {
    x: 0.5 * (
      (2 * p1.x) +
      (-p0.x + p2.x) * localT +
      (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * tt +
      (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * ttt
    ),
    y: 0.5 * (
      (2 * p1.y) +
      (-p0.y + p2.y) * localT +
      (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * tt +
      (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * ttt
    ),
  };
}

// Compute tangent angle at parameter t
function catmullRomTangentAngle(points, t) {
  const dt = 0.001;
  const a = catmullRomPoint(points, Math.max(0, t - dt));
  const b = catmullRomPoint(points, Math.min(1, t + dt));
  return Math.atan2(b.y - a.y, b.x - a.x);
}

// Arc-length parameterization: compute evenly-spaced t values
function computeArcLengthTable(points, samples = 200) {
  const table = [{ t: 0, dist: 0 }];
  let totalDist = 0;
  let prev = catmullRomPoint(points, 0);

  for (let i = 1; i <= samples; i++) {
    const t = i / samples;
    const pt = catmullRomPoint(points, t);
    const dx = pt.x - prev.x;
    const dy = pt.y - prev.y;
    totalDist += Math.sqrt(dx * dx + dy * dy);
    table.push({ t, dist: totalDist });
    prev = pt;
  }
  return { table, totalLength: totalDist };
}

function tAtArcLength(arcTable, targetDist) {
  const { table } = arcTable;
  for (let i = 1; i < table.length; i++) {
    if (table[i].dist >= targetDist) {
      const prev = table[i - 1];
      const curr = table[i];
      const frac = (targetDist - prev.dist) / (curr.dist - prev.dist);
      return prev.t + (curr.t - prev.t) * frac;
    }
  }
  return 1;
}

// Sample the height envelope at a given t (0-1 along main curve).
// Linearly interpolates between adjacent height control points.
function sampleHeightMultiplier(t) {
  if (heightControlPoints.length === 0) return 1.0;
  if (heightControlPoints.length === 1) return heightControlPoints[0].mul;

  // heightControlPoints are kept sorted by t
  if (t <= heightControlPoints[0].t) return heightControlPoints[0].mul;
  if (t >= heightControlPoints[heightControlPoints.length - 1].t) {
    return heightControlPoints[heightControlPoints.length - 1].mul;
  }

  for (let i = 1; i < heightControlPoints.length; i++) {
    if (t <= heightControlPoints[i].t) {
      const prev = heightControlPoints[i - 1];
      const curr = heightControlPoints[i];
      const frac = (t - prev.t) / (curr.t - prev.t);
      return prev.mul + (curr.mul - prev.mul) * frac;
    }
  }
  return 1.0;
}

// Sample the rotation offset from the envelope at a given t.
function sampleHeightRotation(t) {
  if (heightControlPoints.length === 0) return 0;
  if (heightControlPoints.length === 1) return heightControlPoints[0].rot || 0;

  if (t <= heightControlPoints[0].t) return heightControlPoints[0].rot || 0;
  if (t >= heightControlPoints[heightControlPoints.length - 1].t) {
    return heightControlPoints[heightControlPoints.length - 1].rot || 0;
  }

  for (let i = 1; i < heightControlPoints.length; i++) {
    if (t <= heightControlPoints[i].t) {
      const prev = heightControlPoints[i - 1];
      const curr = heightControlPoints[i];
      const frac = (t - prev.t) / (curr.t - prev.t);
      return (prev.rot || 0) + ((curr.rot || 0) - (prev.rot || 0)) * frac;
    }
  }
  return 0;
}

function sampleHeightWidth(t) {
  if (heightControlPoints.length === 0) return 1.0;
  if (heightControlPoints.length === 1) return heightControlPoints[0].wid ?? 1.0;

  const wid0 = heightControlPoints[0].wid ?? 1.0;
  if (t <= heightControlPoints[0].t) return wid0;
  const widLast = heightControlPoints[heightControlPoints.length - 1].wid ?? 1.0;
  if (t >= heightControlPoints[heightControlPoints.length - 1].t) return widLast;

  for (let i = 1; i < heightControlPoints.length; i++) {
    if (t <= heightControlPoints[i].t) {
      const prev = heightControlPoints[i - 1];
      const curr = heightControlPoints[i];
      const frac = (t - prev.t) / (curr.t - prev.t);
      const prevW = prev.wid ?? 1.0;
      const currW = curr.wid ?? 1.0;
      return prevW + (currW - prevW) * frac;
    }
  }
  return 0;
}

// Keep height control points sorted by t
function sortHeightControlPoints() {
  heightControlPoints.sort((a, b) => a.t - b.t);
}

// Distribute spines evenly along the curve
function computeSpinePositions() {
  if (controlPoints.length < 2) return [];

  const arcData = computeArcLengthTable(controlPoints);
  const { totalLength } = arcData;
  const positions = [];

  // Even distribution with spacing factor
  const gap = (totalLength / (spineCount - 1)) * spineSpacing;
  const totalSpan = gap * (spineCount - 1);
  const startOffset = (totalLength - totalSpan) / 2; // center the spines

  for (let i = 0; i < spineCount; i++) {
    const dist = Math.max(0, Math.min(totalLength, startOffset + i * gap));
    const t = tAtArcLength(arcData, dist);
    const pt = catmullRomPoint(controlPoints, t);
    const tangentAngle = catmullRomTangentAngle(controlPoints, t);

    // Default angle: perpendicular to curve (tangent - 90°) + global rotation + envelope rotation
    const envelopeRot = sampleHeightRotation(t);
    const angleDeg = (tangentAngle * 180 / Math.PI) - 90 + globalRotation + envelopeRot;

    const baseScale = spineScale;

    // Apply height envelope multiplier
    const heightMul = sampleHeightMultiplier(t);
    const scale = baseScale * heightMul;

    // Apply width envelope multiplier
    const widthMul = sampleHeightWidth(t);

    positions.push({ x: pt.x, y: pt.y, angleDeg, scale, widthMul, t, idx: i, heightMul });
  }

  return positions;
}

// ── Rendering ──
async function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw reference layers (body + tail silhouettes)
  await drawReferenceLayers();

  // Draw curve
  drawCurve();

  // Draw height guide (parallel line)
  drawHeightGuide();

  // Draw spine sprites (actual PNGs at computed positions)
  const positions = computeSpinePositions();
  await drawSpineSprites(positions);

  // Draw spine markers (direction indicators on top)
  drawSpineMarkers(positions);

  // Draw control points
  drawControlPoints();

  // Update envelope list
  updateEnvelopeList();

  // Update output
  updateOutput(positions);
}

async function drawReferenceLayers() {
  ctx.save();
  ctx.globalAlpha = 0.3;

  // Helper: draw a single layer at its own anchor position
  async function drawLayer(filename, bodyType) {
    const anchor = getAnchor(filename, bodyType);
    const img = await loadImage(filename);
    if (img) ctx.drawImage(img, anchor.x, anchor.y);
  }

  // Body fill + outline (each at its own anchor)
  const bodyFill = BODY_FILENAMES[currentBody]; // e.g. body_stan_mf
  const bodyOutline = bodyFill.replace('_mf', '_o'); // e.g. body_stan_o
  await drawLayer(bodyFill, currentBody);
  await drawLayer(bodyOutline, currentBody);

  // Tail fill + outline (each at its own anchor)
  const tailFill = TAIL_FILENAMES[currentTail]?.[currentLength];
  if (tailFill) {
    const tailOutline = tailFill.replace('_f', '_o'); // e.g. tail_normal_s_o
    await drawLayer(tailFill, currentBody);
    await drawLayer(tailOutline, currentBody);
  }

  // Head fill + outline (each at its own anchor)
  await drawLayer(HEAD_FILENAME, currentBody);
  await drawLayer('head_o', currentBody);

  // Head spines (anchored relative to head_o, each file at its own offset)
  const headSpineEntry = HEAD_SPINE_FILENAMES[currentSpine]?.[currentHeight];
  if (headSpineEntry) {
    const headSpineFiles = Array.isArray(headSpineEntry) ? headSpineEntry : [headSpineEntry];
    const headOAnchor = getAnchor('head_o', currentBody);
    for (const hsFile of headSpineFiles) {
      const spineAnchor = ANCHORS[hsFile] || { x: 0, y: 0 };
      const ax = headOAnchor.x + spineAnchor.x;
      const ay = headOAnchor.y + spineAnchor.y;
      const hsImg = await loadImage(hsFile);
      if (hsImg) ctx.drawImage(hsImg, ax, ay);
    }
  }

  ctx.restore();
}

function drawCurve() {
  if (controlPoints.length < 2) return;

  // Draw the smooth curve
  ctx.beginPath();
  const first = catmullRomPoint(controlPoints, 0);
  ctx.moveTo(first.x, first.y);

  const steps = controlPoints.length * 30;
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    const pt = catmullRomPoint(controlPoints, t);
    ctx.lineTo(pt.x, pt.y);
  }

  ctx.strokeStyle = CURVE_COLOR;
  ctx.lineWidth = 3;
  ctx.stroke();
}

// Compute a point on the parallel height guide curve at parameter t
function heightGuidePoint(points, t, offset) {
  const pt = catmullRomPoint(points, t);
  const angle = catmullRomTangentAngle(points, t);
  // Normal is perpendicular to tangent (rotated -90°, i.e. "above" the curve)
  const nx = -Math.sin(angle);
  const ny =  Math.cos(angle);
  return { x: pt.x + nx * offset, y: pt.y + ny * offset };
}

function drawHeightGuide() {
  if (!showHeightGuide || controlPoints.length < 2) return;

  // Draw the height envelope curve (sampled at many points along main curve)
  const steps = controlPoints.length * 30;
  ctx.beginPath();
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const mul = sampleHeightMultiplier(t);
    const offset = -heightOffset * mul; // scale the visual offset by the multiplier
    const pt = heightGuidePoint(controlPoints, t, offset);
    if (i === 0) ctx.moveTo(pt.x, pt.y);
    else ctx.lineTo(pt.x, pt.y);
  }
  ctx.strokeStyle = '#aa77cc80';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw connecting lines from each spine position to the height guide at that t
  const positions = computeSpinePositions();
  ctx.strokeStyle = '#aa77cc30';
  ctx.lineWidth = 1;
  for (const pos of positions) {
    const mul = sampleHeightMultiplier(pos.t);
    const hPt = heightGuidePoint(controlPoints, pos.t, -heightOffset * mul);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(hPt.x, hPt.y);
    ctx.stroke();
  }

  // Draw height control points as draggable dots on the envelope curve
  for (let i = 0; i < heightControlPoints.length; i++) {
    const hcp = heightControlPoints[i];
    const offset = -heightOffset * hcp.mul;
    const pt = heightGuidePoint(controlPoints, hcp.t, offset);
    const isDragging = isDraggingHeightCP === i;

    // Draw the dot
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, isDragging ? 7 : 5, 0, Math.PI * 2);
    ctx.fillStyle = isDragging ? '#dd99ff' : '#bb88dd';
    ctx.fill();
    ctx.strokeStyle = '#ffffff80';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Label with multiplier and rotation
    ctx.save();
    ctx.font = 'bold 10px monospace';
    ctx.fillStyle = '#dd99ff';
    ctx.textAlign = 'center';
    const rotLabel = (hcp.rot || 0) !== 0 ? ` ${Math.round(hcp.rot)}°` : '';
    ctx.fillText(hcp.mul.toFixed(2) + 'x' + rotLabel, pt.x, pt.y - 10);
    ctx.restore();
  }
}

// Find which height control point is near (cx, cy), returns index or -1
function findHeightControlPoint(cx, cy) {
  if (!showHeightGuide || controlPoints.length < 2) return -1;
  const threshold = 10 / zoom;
  for (let i = 0; i < heightControlPoints.length; i++) {
    const hcp = heightControlPoints[i];
    const offset = -heightOffset * hcp.mul;
    const pt = heightGuidePoint(controlPoints, hcp.t, offset);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
  }
  return -1;
}

// Check if a point is near the height guide envelope curve (for adding new control points)
function isNearHeightGuide(cx, cy) {
  if (!showHeightGuide || controlPoints.length < 2) return false;
  const steps = controlPoints.length * 20;
  const threshold = 12 / zoom;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const mul = sampleHeightMultiplier(t);
    const offset = -heightOffset * mul;
    const pt = heightGuidePoint(controlPoints, t, offset);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    if (Math.sqrt(dx * dx + dy * dy) < threshold) return true;
  }
  return false;
}

// Find the nearest t on the main curve for a given screen point (for inserting height CPs)
function nearestTForPoint(cx, cy) {
  const steps = controlPoints.length * 40;
  let bestT = 0, bestDist = Infinity;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const pt = catmullRomPoint(controlPoints, t);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    const d = dx * dx + dy * dy;
    if (d < bestDist) { bestDist = d; bestT = t; }
  }
  return bestT;
}

async function drawSpineSprites(positions) {
  const files = SPINE_FILENAMES[currentSpine]?.[currentHeight] || [];
  if (positions.length === 0) return;

  if (files.length === 0) {
    // Show "no assets" label near the first spine position
    if (positions.length > 0) {
      ctx.save();
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#884444';
      ctx.textAlign = 'center';
      ctx.fillText(`No ${currentSpine} ${currentHeight} assets`, positions[0].x, positions[0].y - 30);
      ctx.restore();
    }
    return;
  }

  // Load all layers for this spine type
  const imgs = [];
  for (const f of files) {
    const img = await loadImage(f);
    if (img) imgs.push(img);
  }
  if (imgs.length === 0) return;

  for (const pos of positions) {
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(pos.angleDeg * Math.PI / 180);
    ctx.scale(pos.scale * (pos.widthMul ?? 1.0), pos.scale);

    // Draw each layer (fill then outline) centered on the position
    for (const img of imgs) {
      ctx.drawImage(img, -img.width / 2, -img.height, img.width, img.height);
    }
    ctx.restore();
  }
}

function drawSpineMarkers(positions) {
  for (const pos of positions) {
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(pos.angleDeg * Math.PI / 180);

    // Draw spine direction indicator (line pointing "up" from curve)
    const len = 20 * pos.scale;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -len);
    ctx.strokeStyle = SPINE_MARKER_COLOR;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw marker dot
    ctx.beginPath();
    ctx.arc(0, 0, 3, 0, Math.PI * 2);
    ctx.fillStyle = SPINE_MARKER_COLOR;
    ctx.fill();

    // Index label
    ctx.restore();
    ctx.save();
    ctx.font = '10px monospace';
    ctx.fillStyle = '#8a7e72';
    ctx.textAlign = 'center';
    ctx.fillText(pos.idx, pos.x, pos.y + 16);
    ctx.restore();
  }
}

function drawControlPoints() {
  for (let i = 0; i < controlPoints.length; i++) {
    const pt = controlPoints[i];
    const isEndpoint = i === 0 || i === controlPoints.length - 1;

    ctx.beginPath();
    ctx.arc(pt.x, pt.y, isEndpoint ? POINT_RADIUS + 2 : POINT_RADIUS, 0, Math.PI * 2);

    if (i === 0) {
      // Start point (tail connection) — red
      ctx.fillStyle = ENDPOINT_COLOR_START;
      ctx.strokeStyle = '#ff8888';
    } else if (i === controlPoints.length - 1) {
      // End point (body connection) — blue
      ctx.fillStyle = ENDPOINT_COLOR_END;
      ctx.strokeStyle = '#88aaff';
    } else {
      ctx.fillStyle = CONTROL_POINT_COLOR;
      ctx.strokeStyle = '#e0c880';
    }
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.stroke();

    // Label endpoints
    if (isEndpoint) {
      ctx.save();
      ctx.font = 'bold 10px sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.fillText(i === 0 ? 'TAIL' : 'BODY', pt.x, pt.y - POINT_RADIUS - 6);
      ctx.restore();
    }
  }
}

// ── Envelope List UI ──
function updateEnvelopeList() {
  envelopePointCount.textContent = `(${heightControlPoints.length})`;
  envelopeListEl.innerHTML = '';

  for (let i = 0; i < heightControlPoints.length; i++) {
    const hcp = heightControlPoints[i];
    const item = document.createElement('div');
    item.className = 'spine-item';
    item.style.flexWrap = 'wrap';

    const tPct = (hcp.t * 100).toFixed(0);
    const isEndpoint = i === 0 || i === heightControlPoints.length - 1;

    item.innerHTML = `
      <span class="idx" style="color:#bb88dd;">#${i}</span>
      <span class="info" style="min-width:50px;">t: ${tPct}%</span>
      <span class="angle">${hcp.mul.toFixed(2)}x</span>
      <div style="width:100%;display:flex;align-items:center;gap:6px;margin-top:2px;">
        <label style="font-size:10px;color:#8a7e72;min-width:28px;">Rot</label>
        <input type="range" min="-180" max="180" step="1" value="${Math.round(hcp.rot || 0)}"
               style="flex:1;accent-color:#bb88dd;height:3px;" data-hcp-rot="${i}">
        <span style="font-size:10px;color:#d4cdc4;font-family:monospace;min-width:32px;text-align:right;"
              data-hcp-rot-val="${i}">${Math.round(hcp.rot || 0)}°</span>
      </div>
      <div style="width:100%;display:flex;align-items:center;gap:6px;margin-top:2px;">
        <label style="font-size:10px;color:#8a7e72;min-width:28px;">Wid</label>
        <input type="range" min="0" max="3" step="0.05" value="${(hcp.wid ?? 1.0).toFixed(2)}"
               style="flex:1;accent-color:#bb88dd;height:3px;" data-hcp-wid="${i}">
        <span style="font-size:10px;color:#d4cdc4;font-family:monospace;min-width:32px;text-align:right;"
              data-hcp-wid-val="${i}">${(hcp.wid ?? 1.0).toFixed(2)}x</span>
      </div>
    `;

    envelopeListEl.appendChild(item);
  }

  // Attach slider handlers (after DOM insertion)
  for (let i = 0; i < heightControlPoints.length; i++) {
    const slider = envelopeListEl.querySelector(`[data-hcp-rot="${i}"]`);
    const valSpan = envelopeListEl.querySelector(`[data-hcp-rot-val="${i}"]`);
    if (slider) {
      slider.addEventListener('input', () => {
        heightControlPoints[i].rot = parseInt(slider.value);
        valSpan.textContent = slider.value + '°';
        render();
      });
      slider.addEventListener('change', saveAll);
    }

    const widSlider = envelopeListEl.querySelector(`[data-hcp-wid="${i}"]`);
    const widValSpan = envelopeListEl.querySelector(`[data-hcp-wid-val="${i}"]`);
    if (widSlider) {
      widSlider.addEventListener('input', () => {
        heightControlPoints[i].wid = parseFloat(widSlider.value);
        widValSpan.textContent = parseFloat(widSlider.value).toFixed(2) + 'x';
        render();
      });
      widSlider.addEventListener('change', saveAll);
    }
  }
}

// ── Output Generation ──
function updateOutput(positions) {
  if (positions.length === 0) {
    outputText.textContent = 'Draw a path to generate output...';
    return;
  }

  const key = `${currentBody}:${currentTail}_${currentLength}`;
  const curveData = {
    key,
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount,
    spineSpacing,
    spineScale,
    heightOffset,
    perSpineOverrides: { ...perSpineOverrides },
  };

  // Anchor format output
  const lines = [`// Spine anchors for ${key}`, `// Spine type: ${currentSpine}, height: ${currentHeight}`];
  for (const pos of positions) {
    const hMul = pos.heightMul !== undefined ? pos.heightMul : 1.0;
    const wMul = pos.widthMul ?? 1.0;
    lines.push(`  'spine_${pos.idx}:${key}': { x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)}, rot: ${pos.angleDeg.toFixed(1)}, scale: ${pos.scale.toFixed(3)}, wid: ${wMul.toFixed(3)} },`);
  }

  lines.push('');
  lines.push('// Curve definition:');
  lines.push(`// ${JSON.stringify(curveData)}`);

  outputText.textContent = lines.join('\n');
}

// ── Path Key ──
function currentPathKey() {
  return `${currentBody}:${currentTail}_${currentLength}_${currentSpine}_${currentHeight}`;
}

// Snapshot current working path for seeding into a new combo
function snapshotCurrentPath() {
  if (controlPoints.length === 0) return null;
  return {
    controlPoints: controlPoints.map(p => ({ x: p.x, y: p.y })),
    spineCount, spineSpacing, spineScale, heightOffset, globalRotation,
    perSpineOverrides: JSON.parse(JSON.stringify(perSpineOverrides)),
    heightControlPoints: JSON.parse(JSON.stringify(heightControlPoints)),
  };
}

// ── LocalStorage ──
function saveAll() {
  const allPaths = loadAllPaths();
  allPaths[currentPathKey()] = {
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount, spineSpacing, spineScale, heightOffset, globalRotation,
    perSpineOverrides: { ...perSpineOverrides },
    heightControlPoints: heightControlPoints.map(p => ({ t: p.t, mul: p.mul, rot: p.rot || 0, wid: p.wid ?? 1.0 })),
    spineType: currentSpine,
    spineHeight: currentHeight,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(allPaths));
}

function loadAllPaths() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
  } catch { return {}; }
}

function restorePath(seedFrom) {
  const allPaths = loadAllPaths();
  const data = allPaths[currentPathKey()];
  if (data) {
    // Existing saved path — load it
    controlPoints = data.controlPoints || [];
    spineCount = data.spineCount || 10;
    spineSpacing = data.spineSpacing || 1.0;
    spineScale = data.spineScale || 1.0;
    heightOffset = data.heightOffset || 60;
    globalRotation = data.globalRotation || 0;
    perSpineOverrides = data.perSpineOverrides || {};
    heightControlPoints = data.heightControlPoints || [{ t: 0, mul: 1.0, rot: 0, wid: 1.0 }, { t: 1, mul: 1.0, rot: 0, wid: 1.0 }];
  } else if (seedFrom) {
    // No saved path — seed from current working path (deep copy)
    controlPoints = seedFrom.controlPoints.map(p => ({ x: p.x, y: p.y }));
    spineCount = seedFrom.spineCount;
    spineSpacing = seedFrom.spineSpacing;
    spineScale = seedFrom.spineScale;
    heightOffset = seedFrom.heightOffset;
    globalRotation = seedFrom.globalRotation || 0;
    perSpineOverrides = JSON.parse(JSON.stringify(seedFrom.perSpineOverrides));
    heightControlPoints = JSON.parse(JSON.stringify(seedFrom.heightControlPoints || [{ t: 0, mul: 1.0, rot: 0, wid: 1.0 }, { t: 1, mul: 1.0, rot: 0, wid: 1.0 }]));
  } else {
    // No saved path, no seed — blank
    controlPoints = [];
    perSpineOverrides = {};
    heightControlPoints = [{ t: 0, mul: 1.0, rot: 0, wid: 1.0 }, { t: 1, mul: 1.0, rot: 0, wid: 1.0 }];
    globalRotation = 0;
  }
  // Restore sliders to match loaded/seeded state
  spineCountSlider.value = spineCount;
  spineCountVal.textContent = spineCount;
  spineSpacingSlider.value = spineSpacing;
  spineSpacingVal.textContent = spineSpacing.toFixed(2);
  spineScaleSlider.value = spineScale;
  spineScaleVal.textContent = spineScale.toFixed(2);
  heightOffsetSlider.value = heightOffset;
  heightOffsetVal.textContent = Math.round(heightOffset);
  globalRotSlider.value = globalRotation;
  globalRotVal.textContent = globalRotation + '°';
  render();
}

// ── Curve proximity helpers ──
// Find the nearest point on the curve to (cx, cy), returns { t, dist, x, y }
function nearestCurvePoint(cx, cy) {
  if (controlPoints.length < 2) return null;
  const steps = controlPoints.length * 40;
  let best = { t: 0, dist: Infinity, x: 0, y: 0 };
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const pt = catmullRomPoint(controlPoints, t);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < best.dist) best = { t, dist: d, x: pt.x, y: pt.y };
  }
  return best;
}

// Find which segment a t value falls in → insert index
function segmentForT(t) {
  if (controlPoints.length < 2) return 0;
  const n = controlPoints.length - 1;
  const seg = Math.floor(t * n);
  return Math.min(seg + 1, controlPoints.length); // insert after segment start
}

// Find nearest control point to (cx, cy)
function nearestControlPointIdx(cx, cy) {
  let bestIdx = -1;
  let bestDist = Infinity;
  for (let i = 0; i < controlPoints.length; i++) {
    const dx = controlPoints[i].x - cx;
    const dy = controlPoints[i].y - cy;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  return { idx: bestIdx, dist: bestDist };
}

// ── Mouse → Sprite-space coordinates ──
function canvasCoords(e) {
  const rect = container.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left - panX) / zoom,
    y: (e.clientY - rect.top - panY) / zoom,
  };
}

function findPointAt(cx, cy) {
  const threshold = POINT_RADIUS / zoom + 4;
  for (let i = 0; i < controlPoints.length; i++) {
    const dx = controlPoints[i].x - cx;
    const dy = controlPoints[i].y - cy;
    if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
  }
  return -1;
}

// ── Input Handlers ──
canvas.addEventListener('mousedown', (e) => {
  const { x, y } = canvasCoords(e);

  if (spaceHeld || e.button === 1) {
    // Pan mode
    isPanning = true;
    panStartX = e.clientX - panX;
    panStartY = e.clientY - panY;
    canvas.classList.add('dragging');
    e.preventDefault();
    return;
  }

  if (e.button === 2) {
    // Right-click: delete height control point first (if near one, keep min 2)
    if (showHeightGuide && controlPoints.length >= 2) {
      const hcpIdx = findHeightControlPoint(x, y);
      if (hcpIdx >= 0 && heightControlPoints.length > 2) {
        heightControlPoints.splice(hcpIdx, 1);
        render();
        saveAll();
        e.preventDefault();
        return;
      }
    }
    // Right-click: delete curve control point
    const idx = findPointAt(x, y);
    if (idx >= 0) {
      controlPoints.splice(idx, 1);
      render();
    }
    e.preventDefault();
    return;
  }

  // Alt+Click: delete nearest control point on the curve
  if (e.altKey && controlPoints.length > 0) {
    const { idx, dist } = nearestControlPointIdx(x, y);
    const threshold = 50 / zoom; // generous threshold since we're using Alt
    if (idx >= 0 && dist < threshold) {
      controlPoints.splice(idx, 1);
      render();
      saveAll();
    }
    e.preventDefault();
    return;
  }

  // Shift+Click: insert a new control point on the curve at nearest location
  if (e.shiftKey && controlPoints.length >= 2) {
    const nearest = nearestCurvePoint(x, y);
    const threshold = 50 / zoom;
    if (nearest && nearest.dist < threshold) {
      const insertIdx = segmentForT(nearest.t);
      controlPoints.splice(insertIdx, 0, { x: nearest.x, y: nearest.y });
      isDraggingPoint = insertIdx;
      canvas.classList.add('dragging');
      render();
    }
    e.preventDefault();
    return;
  }

  // Check height guide interactions (before regular point adding)
  if (showHeightGuide && controlPoints.length >= 2) {
    // Check for clicking on an existing height control point
    const hcpIdx = findHeightControlPoint(x, y);
    if (hcpIdx >= 0) {
      isDraggingHeightCP = hcpIdx;
      canvas.classList.add('dragging');
      canvas.style.cursor = 'ns-resize';
      e.preventDefault();
      return;
    }

    // Check for clicking on the height guide line → add new control point
    if (isNearHeightGuide(x, y)) {
      const t = nearestTForPoint(x, y);
      const mul = sampleHeightMultiplier(t); // start at the current interpolated value
      const rot = sampleHeightRotation(t); // start at current interpolated rotation
      const wid = sampleHeightWidth(t); // start at current interpolated width
      heightControlPoints.push({ t, mul, rot, wid });
      sortHeightControlPoints();
      // Find the new point's index and start dragging it
      const newIdx = heightControlPoints.findIndex(p => p.t === t && p.mul === mul);
      isDraggingHeightCP = newIdx >= 0 ? newIdx : -1;
      canvas.classList.add('dragging');
      canvas.style.cursor = 'ns-resize';
      render();
      e.preventDefault();
      return;
    }
  }

  // Left-click: drag existing point or add new one
  const hitIdx = findPointAt(x, y);
  if (hitIdx >= 0) {
    isDraggingPoint = hitIdx;
    canvas.classList.add('dragging');
  } else {
    // Add new control point
    controlPoints.push({ x, y });
    isDraggingPoint = controlPoints.length - 1;
    canvas.classList.add('dragging');
    render();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isPanning) {
    panX = e.clientX - panStartX;
    panY = e.clientY - panStartY;
    updateCanvasTransform();
    return;
  }

  if (isDraggingHeightCP >= 0) {
    // Dragging a height control point: compute perpendicular distance from cursor
    // to the main curve at this point's t, then convert to multiplier
    const { x: mx, y: my } = canvasCoords(e);
    const hcp = heightControlPoints[isDraggingHeightCP];
    const curvePt = catmullRomPoint(controlPoints, hcp.t);
    const angle = catmullRomTangentAngle(controlPoints, hcp.t);
    const nx = -Math.sin(angle);
    const ny =  Math.cos(angle);
    // Project mouse offset onto normal direction (negative = above curve)
    const dx = mx - curvePt.x;
    const dy = my - curvePt.y;
    const projDist = -(dx * nx + dy * ny); // positive = above curve
    // Convert pixel distance to multiplier: projDist / heightOffset
    hcp.mul = Math.max(0, Math.round((projDist / heightOffset) * 20) / 20); // snap to 0.05 increments
    render();
    return;
  }

  if (isDraggingHeightGuide) {
    // Use screen-space delta for smooth, zoom-independent dragging
    const rect = container.getBoundingClientRect();
    const screenY = e.clientY - rect.top;
    const screenDelta = heightGuideStartY - screenY;
    // Scale: 1 screen pixel = 0.5 sprite-space units for fine control
    const spriteDelta = screenDelta * 0.5;
    heightOffset = Math.max(1, Math.min(400, heightGuideStartOffset + spriteDelta));
    heightOffsetSlider.value = Math.round(heightOffset);
    heightOffsetVal.textContent = Math.round(heightOffset);
    render();
    return;
  }

  if (isDraggingPoint >= 0) {
    const { x, y } = canvasCoords(e);
    controlPoints[isDraggingPoint].x = x;
    controlPoints[isDraggingPoint].y = y;
    render();
  }

  // Update cursor when hovering over height guide points or line
  if (isDraggingPoint < 0 && isDraggingHeightCP < 0 && !isPanning && showHeightGuide) {
    const { x, y } = canvasCoords(e);
    if (findHeightControlPoint(x, y) >= 0 || isNearHeightGuide(x, y)) {
      canvas.style.cursor = 'ns-resize';
    } else if (!spaceHeld) {
      canvas.style.cursor = 'crosshair';
    }
  }
});

canvas.addEventListener('mouseup', () => {
  if (isPanning) {
    isPanning = false;
    canvas.classList.remove('dragging');
    return;
  }
  if (isDraggingHeightCP >= 0) {
    isDraggingHeightCP = -1;
    canvas.classList.remove('dragging');
    canvas.style.cursor = 'crosshair';
    saveAll();
    return;
  }
  if (isDraggingHeightGuide) {
    isDraggingHeightGuide = false;
    canvas.classList.remove('dragging');
    canvas.style.cursor = 'crosshair';
    saveAll();
    return;
  }
  if (isDraggingPoint >= 0) {
    isDraggingPoint = -1;
    canvas.classList.remove('dragging');
    saveAll();
  }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

// Zoom
container.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = container.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  zoom = Math.max(0.05, Math.min(3, zoom * delta));

  // Zoom toward mouse position
  panX = mx - (mx - panX) * (zoom / oldZoom);
  panY = my - (my - panY) * (zoom / oldZoom);

  updateCanvasTransform();
}, { passive: false });

// Space for pan
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !e.repeat) {
    spaceHeld = true;
    canvas.style.cursor = 'grab';
    e.preventDefault();
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space') {
    spaceHeld = false;
    canvas.style.cursor = 'crosshair';
  }
});

// ── Tab Button Handlers ──
function initTabGroup(selector, callback) {
  const btns = document.querySelectorAll(selector);
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      btns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      callback(btn);
    });
  });
}

initTabGroup('[data-body]', (btn) => {
  const seed = snapshotCurrentPath();
  currentBody = btn.dataset.body;
  restorePath(seed);
});
initTabGroup('[data-tail]', (btn) => {
  const seed = snapshotCurrentPath();
  currentTail = btn.dataset.tail;
  restorePath(seed);
});
initTabGroup('[data-length]', (btn) => {
  const seed = snapshotCurrentPath();
  currentLength = btn.dataset.length;
  restorePath(seed);
});
initTabGroup('[data-spine]', (btn) => {
  const seed = snapshotCurrentPath();
  currentSpine = btn.dataset.spine;
  restorePath(seed);
});
initTabGroup('[data-height]', (btn) => {
  const seed = snapshotCurrentPath();
  currentHeight = btn.dataset.height;
  restorePath(seed);
});

// ── Slider Handlers ──
spineCountSlider.addEventListener('input', () => {
  spineCount = parseInt(spineCountSlider.value);
  spineCountVal.textContent = spineCount;
  render();
});
spineCountSlider.addEventListener('change', saveAll);

spineSpacingSlider.addEventListener('input', () => {
  spineSpacing = parseFloat(spineSpacingSlider.value);
  spineSpacingVal.textContent = spineSpacing.toFixed(2);
  render();
});
spineSpacingSlider.addEventListener('change', saveAll);

spineScaleSlider.addEventListener('input', () => {
  spineScale = parseFloat(spineScaleSlider.value);
  spineScaleVal.textContent = spineScale.toFixed(2);
  render();
});
spineScaleSlider.addEventListener('change', saveAll);

globalRotSlider.addEventListener('input', () => {
  globalRotation = parseInt(globalRotSlider.value);
  globalRotVal.textContent = globalRotation + '°';
  render();
});
globalRotSlider.addEventListener('change', saveAll);

heightOffsetSlider.addEventListener('input', () => {
  heightOffset = parseInt(heightOffsetSlider.value);
  heightOffsetVal.textContent = heightOffset;
  render();
});
heightOffsetSlider.addEventListener('change', saveAll);

showHeightGuideCheckbox.addEventListener('change', () => {
  showHeightGuide = showHeightGuideCheckbox.checked;
  render();
});

// (Per-spine overrides removed — rotation now controlled via envelope points)

// ── Action Buttons ──
document.getElementById('btn-clear-path').addEventListener('click', () => {
  controlPoints = [];
  perSpineOverrides = {};
  heightControlPoints = [{ t: 0, mul: 1.0, rot: 0, wid: 1.0 }, { t: 1, mul: 1.0, rot: 0, wid: 1.0 }];
  globalRotation = 0;
  globalRotSlider.value = 0;
  globalRotVal.textContent = '0°';
  render();
  saveAll();
});

document.getElementById('btn-save').addEventListener('click', () => {
  saveAll();
  const btn = document.getElementById('btn-save');
  btn.textContent = 'Saved!';
  setTimeout(() => { btn.textContent = 'Save'; }, 1200);
});

document.getElementById('btn-copy-anchors').addEventListener('click', () => {
  const positions = computeSpinePositions();
  const key = currentPathKey();
  const lines = positions.map(pos =>
    `  'spine_${pos.idx}:${key}': { x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)}, rot: ${pos.angleDeg.toFixed(1)} },`
  );
  navigator.clipboard.writeText(lines.join('\n'));
  const btn = document.getElementById('btn-copy-anchors');
  btn.textContent = 'Copied!';
  setTimeout(() => { btn.textContent = 'Copy Anchors'; }, 1200);
});

document.getElementById('btn-copy-curve').addEventListener('click', () => {
  const curveData = {
    key: currentPathKey(),
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount, spineSpacing, spineScale, heightOffset, globalRotation,
    perSpineOverrides: { ...perSpineOverrides },
    heightControlPoints: heightControlPoints.map(p => ({ t: p.t, mul: p.mul, rot: p.rot || 0, wid: p.wid ?? 1.0 })),
    spineType: currentSpine,
    spineHeight: currentHeight,
  };
  navigator.clipboard.writeText(JSON.stringify(curveData, null, 2));
  const btn = document.getElementById('btn-copy-curve');
  btn.textContent = 'Copied!';
  setTimeout(() => { btn.textContent = 'Copy Curve'; }, 1200);
});

// ── Init ──
restorePath();
</script>
</body>
</html>
