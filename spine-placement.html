<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dragon Spine Placement Tool</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #1e1a16;
      color: #d4cdc4;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 12px;
      overflow-x: hidden;
    }
    h1 { text-align: center; margin-bottom: 4px; color: #c4a265; font-size: 20px; }
    .subtitle { text-align: center; color: #8a7e72; margin-bottom: 12px; font-size: 13px; }

    .toolbar-row {
      display: flex; gap: 8px; align-items: center; justify-content: center;
      flex-wrap: wrap; margin-bottom: 8px; padding: 6px 8px;
      background: #2a2420; border-radius: 8px; border: 1px solid #3d3530;
    }
    .toolbar-row label { font-size: 12px; color: #8a7e72; }
    .toolbar-row select, .toolbar-row input[type="number"] {
      background: #1e1a16; color: #d4cdc4; border: 1px solid #3d3530;
      border-radius: 4px; padding: 4px 8px; font-size: 12px;
    }
    .toolbar-row select { min-width: 100px; }
    button {
      background: #c4a265; color: #1e1a16; border: none;
      padding: 6px 14px; border-radius: 6px; cursor: pointer;
      font-weight: bold; font-size: 12px; white-space: nowrap;
    }
    button:hover { background: #d4b275; }
    button.secondary { background: #3d3530; color: #d4cdc4; }
    button.secondary:hover { background: #4d4540; }
    button.danger { background: #884444; color: #f0e0e0; }
    button.danger:hover { background: #aa5555; }
    .sep { width: 1px; height: 24px; background: #3d3530; }
    .tab-btn {
      padding: 4px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;
      background: #3d3530; color: #d4cdc4; border: 1px solid #3d3530;
    }
    .tab-btn.active { background: #c4a265; color: #1e1a16; border-color: #c4a265; }
    .tab-btn.green.active { background: #5a8a4a; color: #fff; border-color: #5a8a4a; }
    .tab-btn.purple.active { background: #7a5a9a; color: #fff; border-color: #7a5a9a; }
    .tab-btn.blue.active { background: #4a6a9a; color: #fff; border-color: #4a6a9a; }

    .main-layout {
      display: flex; gap: 12px; height: calc(100vh - 210px); min-height: 500px;
    }

    /* Canvas area */
    .canvas-container {
      flex: 1; position: relative; overflow: hidden;
      background: repeating-conic-gradient(#1a1a1a 0% 25%, #222 0% 50%) 50% / 20px 20px;
      border: 2px solid #3d3530; border-radius: 8px;
    }
    #mainCanvas {
      position: absolute; top: 0; left: 0;
      transform-origin: 0 0; cursor: crosshair;
    }
    #mainCanvas.dragging { cursor: grabbing; }
    .zoom-indicator {
      position: absolute; bottom: 8px; right: 8px;
      background: rgba(30,26,22,0.85); color: #8a7e72;
      padding: 3px 8px; border-radius: 4px; font-size: 11px;
      pointer-events: none;
    }

    /* Side panel */
    .side-panel {
      width: 340px; min-width: 300px;
      display: flex; flex-direction: column; gap: 6px;
    }
    .panel-section {
      background: #2a2420; border: 1px solid #3d3530; border-radius: 8px;
      padding: 8px;
    }
    .panel-section h3 {
      font-size: 12px; color: #c4a265; margin-bottom: 6px;
      text-transform: uppercase; letter-spacing: 1px;
    }
    .slider-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
    }
    .slider-row label { font-size: 11px; color: #8a7e72; min-width: 80px; }
    .slider-row input[type="range"] {
      flex: 1; accent-color: #c4a265; height: 4px;
    }
    .slider-row .val {
      font-size: 11px; color: #d4cdc4; min-width: 36px; text-align: right;
      font-family: monospace;
    }

    .spine-list {
      flex: 1; overflow-y: auto; min-height: 100px; max-height: 250px;
    }
    .spine-item {
      display: flex; align-items: center; gap: 6px;
      padding: 4px 6px; border-radius: 6px; cursor: pointer;
      font-size: 11px; border: 1px solid transparent;
    }
    .spine-item:hover { background: #3d3530; }
    .spine-item.selected { background: #3d3530; border-color: #c4a265; }
    .spine-item .idx { color: #8a7e72; min-width: 20px; }
    .spine-item .info { flex: 1; color: #d4cdc4; }
    .spine-item .angle { color: #8a7e72; font-family: monospace; font-size: 10px; }

    .override-row {
      display: flex; align-items: center; gap: 6px; margin-top: 4px;
    }
    .override-row label { font-size: 11px; color: #8a7e72; min-width: 60px; }
    .override-row input {
      width: 60px; background: #1e1a16; color: #d4cdc4; border: 1px solid #3d3530;
      border-radius: 4px; padding: 3px 6px; font-size: 11px; font-family: monospace;
    }

    .output-box {
      background: #1e1a16; border: 1px solid #3d3530; border-radius: 8px;
      padding: 8px; max-height: 200px; overflow-y: auto;
    }
    .output-box pre {
      font-size: 10px; color: #8a7e72; white-space: pre-wrap;
      word-break: break-all; font-family: 'Courier New', monospace;
    }

    .instructions {
      font-size: 11px; color: #6a5a4a; line-height: 1.5;
      padding: 4px 0;
    }
    .instructions kbd {
      background: #3d3530; padding: 1px 5px; border-radius: 3px;
      font-size: 10px; color: #d4cdc4;
    }
  </style>
</head>
<body>
  <h1>Spine Placement Tool</h1>
  <p class="subtitle">Draw a spine path along the dragon's back/tail, distribute spine sprites along it</p>

  <!-- Toolbar Row 1: Body + Tail selection -->
  <div class="toolbar-row">
    <label>Body:</label>
    <div class="tab-btn green active" data-body="standard">Standard</div>
    <div class="tab-btn green" data-body="sinuous">Sinuous</div>
    <div class="tab-btn green" data-body="bulky">Bulky</div>
    <span class="sep"></span>
    <label>Tail:</label>
    <div class="tab-btn purple active" data-tail="normal">Normal</div>
    <div class="tab-btn purple" data-tail="whip">Whip</div>
    <div class="tab-btn purple" data-tail="heavy">Heavy</div>
    <span class="sep"></span>
    <label>Length:</label>
    <div class="tab-btn blue active" data-length="medium">Med</div>
    <div class="tab-btn blue" data-length="short">Short</div>
    <div class="tab-btn blue" data-length="long">Long</div>
  </div>

  <!-- Toolbar Row 2: Spine type + actions -->
  <div class="toolbar-row">
    <label>Spine:</label>
    <div class="tab-btn active" data-spine="ridge">Ridge</div>
    <div class="tab-btn" data-spine="spike">Spike</div>
    <div class="tab-btn" data-spine="sail">Sail</div>
    <span class="sep"></span>
    <label>Height:</label>
    <div class="tab-btn active" data-height="medium">Med</div>
    <div class="tab-btn" data-height="low">Low</div>
    <div class="tab-btn" data-height="tall">Tall</div>
    <span class="sep"></span>
    <button id="btn-clear-path" class="danger">Clear Path</button>
    <button id="btn-save" class="secondary">Save</button>
    <button id="btn-copy-anchors">Copy Anchors</button>
    <button id="btn-copy-curve">Copy Curve</button>
  </div>

  <div class="main-layout">
    <!-- Canvas Area -->
    <div class="canvas-container" id="canvasContainer">
      <canvas id="mainCanvas"></canvas>
      <div class="zoom-indicator" id="zoomIndicator">100%</div>
    </div>

    <!-- Side Panel -->
    <div class="side-panel">
      <!-- Curve Controls -->
      <div class="panel-section">
        <h3>Curve Controls</h3>
        <div class="slider-row">
          <label>Spine Count</label>
          <input type="range" id="spine-count" min="2" max="60" value="10">
          <span class="val" id="spine-count-val">10</span>
        </div>
        <div class="slider-row">
          <label>Spacing</label>
          <input type="range" id="spine-spacing" min="0.5" max="2.0" step="0.05" value="1.0">
          <span class="val" id="spine-spacing-val">1.0</span>
        </div>
        <div class="slider-row">
          <label>Scale</label>
          <input type="range" id="spine-scale" min="0.3" max="2.0" step="0.05" value="1.0">
          <span class="val" id="spine-scale-val">1.0</span>
        </div>
        <div class="slider-row">
          <label>Height Offset</label>
          <input type="range" id="height-offset" min="1" max="400" step="1" value="60">
          <span class="val" id="height-offset-val">60</span>
        </div>
        <label style="font-size:11px; color:#8a7e72; display:flex; align-items:center; gap:4px; margin-top:2px; cursor:pointer;">
          <input type="checkbox" id="show-height-guide" checked style="accent-color:#c4a265;">
          Show height guide line
        </label>
        <div class="instructions">
          <kbd>Click</kbd> canvas to add points.
          <kbd>Drag</kbd> points to adjust.
          <kbd>Shift+Click</kbd> curve to insert point.
          <kbd>Alt+Click</kbd> curve to delete nearest point.
          <kbd>Right-click</kbd> point to delete.
          <kbd>Scroll</kbd> to zoom. <kbd>Space+drag</kbd> to pan.
          <br>Drag the <span style="color:#aa77cc;">purple height line</span> to adjust spine heights.
        </div>
      </div>

      <!-- Spine Point List -->
      <div class="panel-section" style="flex:1;display:flex;flex-direction:column;">
        <h3>Spine Points <span id="spine-point-count" style="color:#8a7e72;font-weight:normal;">(0)</span></h3>
        <div class="spine-list" id="spine-list"></div>
        <div id="override-panel" style="display:none;">
          <div class="override-row">
            <label>Angle°</label>
            <input type="number" id="override-angle" step="1" value="0">
            <button class="secondary" id="btn-reset-angle" style="padding:3px 8px;">Reset</button>
          </div>
          <div class="override-row">
            <label>Scale</label>
            <input type="number" id="override-scale" step="0.05" value="1.0">
            <button class="secondary" id="btn-reset-scale" style="padding:3px 8px;">Reset</button>
          </div>
        </div>
      </div>

      <!-- Output -->
      <div class="panel-section">
        <h3>Output</h3>
        <div class="output-box" id="output-box">
          <pre id="output-text">Draw a path to generate output...</pre>
        </div>
      </div>
    </div>
  </div>

<script type="module">
import {
  ANCHORS,
  SPRITE_WIDTH,
  SPRITE_HEIGHT,
} from './js/sprite-config.js';

// ── Constants ──
const ASSET_BASE = 'assets/sprites/';
const BODY_TYPES = ['standard', 'sinuous', 'bulky'];
const TAIL_STYLES = ['normal', 'whip', 'heavy'];
const TAIL_LENGTHS = ['short', 'medium', 'long'];
const SPINE_TYPES = ['ridge', 'spike', 'sail'];
const SPINE_HEIGHTS = ['low', 'medium', 'tall'];

// Repeating spine asset filenames per type and height
// Each entry is an array of filenames to layer (fill first, then outline)
const SPINE_FILENAMES = {
  spike: { low: ['spine_spike_S'], medium: ['spine_spike_M'], tall: ['spine_spike_L'] },
  sail:  { low: ['spine_sail_S_f', 'spine_sail_S_o'], medium: ['spine_sail_M_f', 'spine_sail_M_o'], tall: ['spine_sail_L_f', 'spine_sail_L_o'] },
  ridge: { low: ['spine_ridge_S_f', 'spine_ridge_S_o'], medium: ['spine_ridge_M_f', 'spine_ridge_M_o'], tall: ['spine_ridge_L_f', 'spine_ridge_L_o'] },
};

const BODY_FILENAMES = {
  standard: 'body_stan_mf',
  sinuous:  'body_sin_mf',
  bulky:    'body_bulk_mf',
};
const TAIL_FILENAMES = {
  normal: { short: 'tail_normal_s_f', medium: 'tail_normal_m_f', long: 'tail_normal_l_f' },
  whip:   { short: 'tail_whip_s_f',   medium: 'tail_whip_m_f',   long: 'tail_whip_l_f' },
  heavy:  { short: 'tail_heavy_s_f',  medium: 'tail_heavy_m_f',  long: 'tail_heavy_l_f' },
};

// Head spine filenames per type/height (same type/height as body spines)
const HEAD_SPINE_FILENAMES = {
  spike: { low: 'spinehead_spike_S', medium: 'spinehead_spike_M', tall: 'spinehead_spike_L' },
  sail:  { low: ['spinehead_sail_S_f', 'spinehead_sail_S_o'], medium: ['spinehead_sail_M_f', 'spinehead_sail_M_o'], tall: ['spinehead_sail_L_f', 'spinehead_sail_L_o'] },
  ridge: { low: ['spinehead_ridge_S_f', 'spinehead_ridge_S_o'], medium: ['spinehead_ridge_M_f', 'spinehead_ridge_M_o'], tall: ['spinehead_ridge_L_f', 'spinehead_ridge_L_o'] },
};

const HEAD_FILENAME = 'head_f';

const POINT_RADIUS = 8;
const CONTROL_POINT_COLOR = '#c4a265';
const CURVE_COLOR = '#c4a26580';
const SPINE_MARKER_COLOR = '#6a9f5b';
const ENDPOINT_COLOR_START = '#cc5555';
const ENDPOINT_COLOR_END = '#5588cc';

const STORAGE_KEY = 'dragon-spine-paths-v1';

// ── State ──
let currentBody = 'standard';
let currentTail = 'normal';
let currentLength = 'medium';
let currentSpine = 'ridge';
let currentHeight = 'medium';

let controlPoints = [];   // Array of { x, y } in sprite-space coordinates
let spineCount = 10;
let spineSpacing = 1.0;
let spineScale = 1.0;
let perSpineOverrides = {}; // { index: { angleDeg, scale } }
let selectedSpineIdx = -1;

// Height guide
let heightOffset = 60;       // Perpendicular distance from main curve (in sprite-space px)
let showHeightGuide = true;
let isDraggingHeightGuide = false;
let heightGuideStartY = 0;
let heightGuideStartOffset = 0;

// Pan / Zoom
let zoom = 0.3;
let panX = 0;
let panY = 0;
let isPanning = false;
let panStartX = 0, panStartY = 0;
let isDraggingPoint = -1;
let spaceHeld = false;

// Cached images
const imageCache = new Map();

// ── DOM refs ──
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');
const zoomIndicator = document.getElementById('zoomIndicator');
const spineCountSlider = document.getElementById('spine-count');
const spineCountVal = document.getElementById('spine-count-val');
const spineSpacingSlider = document.getElementById('spine-spacing');
const spineSpacingVal = document.getElementById('spine-spacing-val');
const spineScaleSlider = document.getElementById('spine-scale');
const spineScaleVal = document.getElementById('spine-scale-val');
const spineListEl = document.getElementById('spine-list');
const spinePointCount = document.getElementById('spine-point-count');
const overridePanel = document.getElementById('override-panel');
const overrideAngle = document.getElementById('override-angle');
const overrideScale = document.getElementById('override-scale');
const outputText = document.getElementById('output-text');
const heightOffsetSlider = document.getElementById('height-offset');
const heightOffsetVal = document.getElementById('height-offset-val');
const showHeightGuideCheckbox = document.getElementById('show-height-guide');

// ── Canvas Setup ──
canvas.width = SPRITE_WIDTH;
canvas.height = SPRITE_HEIGHT;

function updateCanvasTransform() {
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
  zoomIndicator.textContent = `${Math.round(zoom * 100)}%`;
}
updateCanvasTransform();

// ── Image Loading ──
function loadImage(filename) {
  const key = filename + '.png';
  if (imageCache.has(key)) return Promise.resolve(imageCache.get(key));
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { imageCache.set(key, img); resolve(img); };
    img.onerror = () => resolve(null);
    img.src = ASSET_BASE + key;
  });
}

function getAnchor(filename, bodyType) {
  const keyed = ANCHORS[`${filename}:${bodyType}`];
  if (keyed) return keyed;
  return ANCHORS[filename] || { x: 0, y: 0 };
}

// ── Bézier Math ──
// Evaluate a Catmull-Rom spline through the control points at parameter t ∈ [0, 1]
// This gives a smooth curve that passes through ALL control points.
function catmullRomPoint(points, t) {
  if (points.length < 2) return points[0] || { x: 0, y: 0 };
  if (points.length === 2) {
    return {
      x: points[0].x + (points[1].x - points[0].x) * t,
      y: points[0].y + (points[1].y - points[0].y) * t,
    };
  }

  const n = points.length - 1;
  const segment = Math.min(Math.floor(t * n), n - 1);
  const localT = t * n - segment;

  // Get 4 points for this segment (with endpoint mirroring)
  const p0 = points[Math.max(0, segment - 1)];
  const p1 = points[segment];
  const p2 = points[Math.min(n, segment + 1)];
  const p3 = points[Math.min(n, segment + 2)];

  const tt = localT * localT;
  const ttt = tt * localT;

  return {
    x: 0.5 * (
      (2 * p1.x) +
      (-p0.x + p2.x) * localT +
      (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * tt +
      (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * ttt
    ),
    y: 0.5 * (
      (2 * p1.y) +
      (-p0.y + p2.y) * localT +
      (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * tt +
      (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * ttt
    ),
  };
}

// Compute tangent angle at parameter t
function catmullRomTangentAngle(points, t) {
  const dt = 0.001;
  const a = catmullRomPoint(points, Math.max(0, t - dt));
  const b = catmullRomPoint(points, Math.min(1, t + dt));
  return Math.atan2(b.y - a.y, b.x - a.x);
}

// Arc-length parameterization: compute evenly-spaced t values
function computeArcLengthTable(points, samples = 200) {
  const table = [{ t: 0, dist: 0 }];
  let totalDist = 0;
  let prev = catmullRomPoint(points, 0);

  for (let i = 1; i <= samples; i++) {
    const t = i / samples;
    const pt = catmullRomPoint(points, t);
    const dx = pt.x - prev.x;
    const dy = pt.y - prev.y;
    totalDist += Math.sqrt(dx * dx + dy * dy);
    table.push({ t, dist: totalDist });
    prev = pt;
  }
  return { table, totalLength: totalDist };
}

function tAtArcLength(arcTable, targetDist) {
  const { table } = arcTable;
  for (let i = 1; i < table.length; i++) {
    if (table[i].dist >= targetDist) {
      const prev = table[i - 1];
      const curr = table[i];
      const frac = (targetDist - prev.dist) / (curr.dist - prev.dist);
      return prev.t + (curr.t - prev.t) * frac;
    }
  }
  return 1;
}

// Distribute spines evenly along the curve
function computeSpinePositions() {
  if (controlPoints.length < 2) return [];

  const arcData = computeArcLengthTable(controlPoints);
  const { totalLength } = arcData;
  const positions = [];

  // Even distribution with spacing factor
  const gap = (totalLength / (spineCount - 1)) * spineSpacing;
  const totalSpan = gap * (spineCount - 1);
  const startOffset = (totalLength - totalSpan) / 2; // center the spines

  for (let i = 0; i < spineCount; i++) {
    const dist = Math.max(0, Math.min(totalLength, startOffset + i * gap));
    const t = tAtArcLength(arcData, dist);
    const pt = catmullRomPoint(controlPoints, t);
    const tangentAngle = catmullRomTangentAngle(controlPoints, t);

    // Default angle: perpendicular to curve (tangent - 90°)
    const defaultAngleDeg = (tangentAngle * 180 / Math.PI) - 90;

    // Apply per-spine overrides
    const override = perSpineOverrides[i] || {};
    const angleDeg = override.angleDeg !== undefined ? override.angleDeg : defaultAngleDeg;
    const scale = (override.scale !== undefined ? override.scale : 1.0) * spineScale;

    positions.push({ x: pt.x, y: pt.y, angleDeg, scale, t, idx: i });
  }

  return positions;
}

// ── Rendering ──
async function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw reference layers (body + tail silhouettes)
  await drawReferenceLayers();

  // Draw curve
  drawCurve();

  // Draw height guide (parallel line)
  drawHeightGuide();

  // Draw spine sprites (actual PNGs at computed positions)
  const positions = computeSpinePositions();
  await drawSpineSprites(positions);

  // Draw spine markers (direction indicators on top)
  drawSpineMarkers(positions);

  // Draw control points
  drawControlPoints();

  // Update spine list
  updateSpineList(positions);

  // Update output
  updateOutput(positions);
}

async function drawReferenceLayers() {
  ctx.save();
  ctx.globalAlpha = 0.3;

  // Helper: draw fill + outline for a given base filename and anchor
  async function drawFillAndOutline(fillFile, outlineFile, anchorX, anchorY) {
    const fillImg = await loadImage(fillFile);
    if (fillImg) ctx.drawImage(fillImg, anchorX, anchorY);
    const outImg = await loadImage(outlineFile);
    if (outImg) ctx.drawImage(outImg, anchorX, anchorY);
  }

  // Body fill + outline
  const bodyFill = BODY_FILENAMES[currentBody]; // e.g. body_stan_mf
  const bodyOutline = bodyFill.replace('_mf', '_o'); // e.g. body_stan_o
  const bodyAnchor = getAnchor(bodyFill, currentBody);
  await drawFillAndOutline(bodyFill, bodyOutline, bodyAnchor.x, bodyAnchor.y);

  // Tail fill + outline
  const tailFill = TAIL_FILENAMES[currentTail]?.[currentLength];
  if (tailFill) {
    const tailOutline = tailFill.replace('_f', '_o'); // e.g. tail_normal_s_o
    const tailAnchor = getAnchor(tailFill, currentBody);
    await drawFillAndOutline(tailFill, tailOutline, tailAnchor.x, tailAnchor.y);
  }

  // Head fill + outline
  const headAnchorKey = `${HEAD_FILENAME}:${currentBody}`;
  const headAnchor = ANCHORS[headAnchorKey] || { x: 0, y: 0 };
  await drawFillAndOutline(HEAD_FILENAME, 'head_o', headAnchor.x, headAnchor.y);

  // Head spines (anchored relative to head_o like horns)
  const headSpineEntry = HEAD_SPINE_FILENAMES[currentSpine]?.[currentHeight];
  if (headSpineEntry) {
    // Entry is either a single filename string (spike) or an array of filenames (ridge/sail fill+outline)
    const headSpineFiles = Array.isArray(headSpineEntry) ? headSpineEntry : [headSpineEntry];
    const headOAnchor = ANCHORS[`head_o:${currentBody}`] || { x: 0, y: 0 };
    // Use first file's anchor for positioning (all layers in a set share the same anchor)
    const spineAnchor = ANCHORS[headSpineFiles[0]] || { x: 0, y: 0 };
    const ax = headOAnchor.x + spineAnchor.x;
    const ay = headOAnchor.y + spineAnchor.y;
    for (const hsFile of headSpineFiles) {
      const hsImg = await loadImage(hsFile);
      if (hsImg) ctx.drawImage(hsImg, ax, ay);
    }
  }

  ctx.restore();
}

function drawCurve() {
  if (controlPoints.length < 2) return;

  // Draw the smooth curve
  ctx.beginPath();
  const first = catmullRomPoint(controlPoints, 0);
  ctx.moveTo(first.x, first.y);

  const steps = controlPoints.length * 30;
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    const pt = catmullRomPoint(controlPoints, t);
    ctx.lineTo(pt.x, pt.y);
  }

  ctx.strokeStyle = CURVE_COLOR;
  ctx.lineWidth = 3;
  ctx.stroke();
}

// Compute a point on the parallel height guide curve at parameter t
function heightGuidePoint(points, t, offset) {
  const pt = catmullRomPoint(points, t);
  const angle = catmullRomTangentAngle(points, t);
  // Normal is perpendicular to tangent (rotated -90°, i.e. "above" the curve)
  const nx = -Math.sin(angle);
  const ny =  Math.cos(angle);
  return { x: pt.x + nx * offset, y: pt.y + ny * offset };
}

function drawHeightGuide() {
  if (!showHeightGuide || controlPoints.length < 2) return;

  const steps = controlPoints.length * 30;
  const offset = -heightOffset; // negative = above the curve

  // Draw the parallel curve
  ctx.beginPath();
  const first = heightGuidePoint(controlPoints, 0, offset);
  ctx.moveTo(first.x, first.y);

  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    const pt = heightGuidePoint(controlPoints, t, offset);
    ctx.lineTo(pt.x, pt.y);
  }

  ctx.strokeStyle = '#aa77cc80';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw connecting lines from each spine position to the height guide
  const positions = computeSpinePositions();
  ctx.strokeStyle = '#aa77cc30';
  ctx.lineWidth = 1;
  for (const pos of positions) {
    const hPt = heightGuidePoint(controlPoints, pos.t, offset);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(hPt.x, hPt.y);
    ctx.stroke();
  }
}

// Check if a point is near the height guide curve (for dragging)
function isNearHeightGuide(cx, cy) {
  if (!showHeightGuide || controlPoints.length < 2) return false;
  const offset = -heightOffset;
  const steps = controlPoints.length * 20;
  const threshold = 12 / zoom;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const pt = heightGuidePoint(controlPoints, t, offset);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    if (Math.sqrt(dx * dx + dy * dy) < threshold) return true;
  }
  return false;
}

async function drawSpineSprites(positions) {
  const files = SPINE_FILENAMES[currentSpine]?.[currentHeight] || [];
  if (positions.length === 0) return;

  if (files.length === 0) {
    // Show "no assets" label near the first spine position
    if (positions.length > 0) {
      ctx.save();
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#884444';
      ctx.textAlign = 'center';
      ctx.fillText(`No ${currentSpine} ${currentHeight} assets`, positions[0].x, positions[0].y - 30);
      ctx.restore();
    }
    return;
  }

  // Load all layers for this spine type
  const imgs = [];
  for (const f of files) {
    const img = await loadImage(f);
    if (img) imgs.push(img);
  }
  if (imgs.length === 0) return;

  for (const pos of positions) {
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(pos.angleDeg * Math.PI / 180);
    ctx.scale(pos.scale, pos.scale);

    // Draw each layer (fill then outline) centered on the position
    for (const img of imgs) {
      ctx.drawImage(img, -img.width / 2, -img.height, img.width, img.height);
    }
    ctx.restore();
  }
}

function drawSpineMarkers(positions) {
  for (const pos of positions) {
    const isSelected = pos.idx === selectedSpineIdx;
    const hasOverride = perSpineOverrides[pos.idx] !== undefined;

    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(pos.angleDeg * Math.PI / 180);

    // Draw spine direction indicator (line pointing "up" from curve)
    const len = 20 * pos.scale;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -len);
    ctx.strokeStyle = isSelected ? '#ffffff' : (hasOverride ? '#cc8855' : SPINE_MARKER_COLOR);
    ctx.lineWidth = isSelected ? 3 : 2;
    ctx.stroke();

    // Draw marker dot
    ctx.beginPath();
    ctx.arc(0, 0, isSelected ? 5 : 3, 0, Math.PI * 2);
    ctx.fillStyle = isSelected ? '#ffffff' : (hasOverride ? '#cc8855' : SPINE_MARKER_COLOR);
    ctx.fill();

    // Index label
    ctx.restore();
    ctx.save();
    ctx.font = '10px monospace';
    ctx.fillStyle = isSelected ? '#ffffff' : '#8a7e72';
    ctx.textAlign = 'center';
    ctx.fillText(pos.idx, pos.x, pos.y + 16);
    ctx.restore();
  }
}

function drawControlPoints() {
  for (let i = 0; i < controlPoints.length; i++) {
    const pt = controlPoints[i];
    const isEndpoint = i === 0 || i === controlPoints.length - 1;

    ctx.beginPath();
    ctx.arc(pt.x, pt.y, isEndpoint ? POINT_RADIUS + 2 : POINT_RADIUS, 0, Math.PI * 2);

    if (i === 0) {
      // Start point (tail connection) — red
      ctx.fillStyle = ENDPOINT_COLOR_START;
      ctx.strokeStyle = '#ff8888';
    } else if (i === controlPoints.length - 1) {
      // End point (body connection) — blue
      ctx.fillStyle = ENDPOINT_COLOR_END;
      ctx.strokeStyle = '#88aaff';
    } else {
      ctx.fillStyle = CONTROL_POINT_COLOR;
      ctx.strokeStyle = '#e0c880';
    }
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.stroke();

    // Label endpoints
    if (isEndpoint) {
      ctx.save();
      ctx.font = 'bold 10px sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.fillText(i === 0 ? 'TAIL' : 'BODY', pt.x, pt.y - POINT_RADIUS - 6);
      ctx.restore();
    }
  }
}

// ── Spine List UI ──
function updateSpineList(positions) {
  spinePointCount.textContent = `(${positions.length})`;
  spineListEl.innerHTML = '';

  for (const pos of positions) {
    const item = document.createElement('div');
    item.className = 'spine-item' + (pos.idx === selectedSpineIdx ? ' selected' : '');

    const hasOverride = perSpineOverrides[pos.idx] !== undefined;
    item.innerHTML = `
      <span class="idx">#${pos.idx}</span>
      <span class="info">${Math.round(pos.x)}, ${Math.round(pos.y)}</span>
      <span class="angle">${pos.angleDeg.toFixed(1)}°${hasOverride ? ' ✎' : ''}</span>
    `;

    item.addEventListener('click', () => {
      selectedSpineIdx = pos.idx;
      showOverridePanel(pos);
      render();
    });

    spineListEl.appendChild(item);
  }
}

function showOverridePanel(pos) {
  overridePanel.style.display = 'block';
  const override = perSpineOverrides[pos.idx] || {};
  overrideAngle.value = override.angleDeg !== undefined ? override.angleDeg : Math.round(pos.angleDeg);
  overrideScale.value = override.scale !== undefined ? override.scale : 1.0;
}

// ── Output Generation ──
function updateOutput(positions) {
  if (positions.length === 0) {
    outputText.textContent = 'Draw a path to generate output...';
    return;
  }

  const key = `${currentBody}:${currentTail}_${currentLength}`;
  const curveData = {
    key,
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount,
    spineSpacing,
    spineScale,
    heightOffset,
    perSpineOverrides: { ...perSpineOverrides },
  };

  // Anchor format output
  const lines = [`// Spine anchors for ${key}`, `// Spine type: ${currentSpine}, height: ${currentHeight}`];
  for (const pos of positions) {
    lines.push(`  'spine_${pos.idx}:${key}': { x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)}, rot: ${pos.angleDeg.toFixed(1)} },`);
  }

  lines.push('');
  lines.push('// Curve definition:');
  lines.push(`// ${JSON.stringify(curveData)}`);

  outputText.textContent = lines.join('\n');
}

// ── Path Key ──
function currentPathKey() {
  return `${currentBody}:${currentTail}_${currentLength}`;
}

// Snapshot current working path for seeding into a new combo
function snapshotCurrentPath() {
  if (controlPoints.length === 0) return null;
  return {
    controlPoints: controlPoints.map(p => ({ x: p.x, y: p.y })),
    spineCount, spineSpacing, spineScale, heightOffset,
    perSpineOverrides: JSON.parse(JSON.stringify(perSpineOverrides)),
  };
}

// ── LocalStorage ──
function saveAll() {
  const allPaths = loadAllPaths();
  allPaths[currentPathKey()] = {
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount, spineSpacing, spineScale, heightOffset,
    perSpineOverrides: { ...perSpineOverrides },
    spineType: currentSpine,
    spineHeight: currentHeight,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(allPaths));
}

function loadAllPaths() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
  } catch { return {}; }
}

function restorePath(seedFrom) {
  const allPaths = loadAllPaths();
  const data = allPaths[currentPathKey()];
  if (data) {
    // Existing saved path — load it
    controlPoints = data.controlPoints || [];
    spineCount = data.spineCount || 10;
    spineSpacing = data.spineSpacing || 1.0;
    spineScale = data.spineScale || 1.0;
    heightOffset = data.heightOffset || 60;
    perSpineOverrides = data.perSpineOverrides || {};
  } else if (seedFrom) {
    // No saved path — seed from current working path (deep copy)
    controlPoints = seedFrom.controlPoints.map(p => ({ x: p.x, y: p.y }));
    spineCount = seedFrom.spineCount;
    spineSpacing = seedFrom.spineSpacing;
    spineScale = seedFrom.spineScale;
    heightOffset = seedFrom.heightOffset;
    perSpineOverrides = JSON.parse(JSON.stringify(seedFrom.perSpineOverrides));
  } else {
    // No saved path, no seed — blank
    controlPoints = [];
    perSpineOverrides = {};
  }
  // Restore sliders to match loaded/seeded state
  spineCountSlider.value = spineCount;
  spineCountVal.textContent = spineCount;
  spineSpacingSlider.value = spineSpacing;
  spineSpacingVal.textContent = spineSpacing.toFixed(2);
  spineScaleSlider.value = spineScale;
  spineScaleVal.textContent = spineScale.toFixed(2);
  heightOffsetSlider.value = heightOffset;
  heightOffsetVal.textContent = Math.round(heightOffset);
  selectedSpineIdx = -1;
  overridePanel.style.display = 'none';
  render();
}

// ── Curve proximity helpers ──
// Find the nearest point on the curve to (cx, cy), returns { t, dist, x, y }
function nearestCurvePoint(cx, cy) {
  if (controlPoints.length < 2) return null;
  const steps = controlPoints.length * 40;
  let best = { t: 0, dist: Infinity, x: 0, y: 0 };
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const pt = catmullRomPoint(controlPoints, t);
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < best.dist) best = { t, dist: d, x: pt.x, y: pt.y };
  }
  return best;
}

// Find which segment a t value falls in → insert index
function segmentForT(t) {
  if (controlPoints.length < 2) return 0;
  const n = controlPoints.length - 1;
  const seg = Math.floor(t * n);
  return Math.min(seg + 1, controlPoints.length); // insert after segment start
}

// Find nearest control point to (cx, cy)
function nearestControlPointIdx(cx, cy) {
  let bestIdx = -1;
  let bestDist = Infinity;
  for (let i = 0; i < controlPoints.length; i++) {
    const dx = controlPoints[i].x - cx;
    const dy = controlPoints[i].y - cy;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  return { idx: bestIdx, dist: bestDist };
}

// ── Mouse → Sprite-space coordinates ──
function canvasCoords(e) {
  const rect = container.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left - panX) / zoom,
    y: (e.clientY - rect.top - panY) / zoom,
  };
}

function findPointAt(cx, cy) {
  const threshold = POINT_RADIUS / zoom + 4;
  for (let i = 0; i < controlPoints.length; i++) {
    const dx = controlPoints[i].x - cx;
    const dy = controlPoints[i].y - cy;
    if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
  }
  return -1;
}

// ── Input Handlers ──
canvas.addEventListener('mousedown', (e) => {
  const { x, y } = canvasCoords(e);

  if (spaceHeld || e.button === 1) {
    // Pan mode
    isPanning = true;
    panStartX = e.clientX - panX;
    panStartY = e.clientY - panY;
    canvas.classList.add('dragging');
    e.preventDefault();
    return;
  }

  if (e.button === 2) {
    // Right-click: delete point
    const idx = findPointAt(x, y);
    if (idx >= 0) {
      controlPoints.splice(idx, 1);
      // Remap overrides
      const newOverrides = {};
      for (const [k, v] of Object.entries(perSpineOverrides)) {
        const ki = parseInt(k);
        if (ki < spineCount) newOverrides[ki] = v;
      }
      perSpineOverrides = newOverrides;
      render();
    }
    e.preventDefault();
    return;
  }

  // Alt+Click: delete nearest control point on the curve
  if (e.altKey && controlPoints.length > 0) {
    const { idx, dist } = nearestControlPointIdx(x, y);
    const threshold = 50 / zoom; // generous threshold since we're using Alt
    if (idx >= 0 && dist < threshold) {
      controlPoints.splice(idx, 1);
      render();
      saveAll();
    }
    e.preventDefault();
    return;
  }

  // Shift+Click: insert a new control point on the curve at nearest location
  if (e.shiftKey && controlPoints.length >= 2) {
    const nearest = nearestCurvePoint(x, y);
    const threshold = 50 / zoom;
    if (nearest && nearest.dist < threshold) {
      const insertIdx = segmentForT(nearest.t);
      controlPoints.splice(insertIdx, 0, { x: nearest.x, y: nearest.y });
      isDraggingPoint = insertIdx;
      canvas.classList.add('dragging');
      render();
    }
    e.preventDefault();
    return;
  }

  // Check if clicking on height guide line (for dragging)
  if (showHeightGuide && isNearHeightGuide(x, y)) {
    isDraggingHeightGuide = true;
    const rect = container.getBoundingClientRect();
    heightGuideStartY = e.clientY - rect.top; // screen-space Y
    heightGuideStartOffset = heightOffset;
    canvas.classList.add('dragging');
    canvas.style.cursor = 'ns-resize';
    e.preventDefault();
    return;
  }

  // Left-click: drag existing point or add new one
  const hitIdx = findPointAt(x, y);
  if (hitIdx >= 0) {
    isDraggingPoint = hitIdx;
    canvas.classList.add('dragging');
  } else {
    // Add new control point
    controlPoints.push({ x, y });
    isDraggingPoint = controlPoints.length - 1;
    canvas.classList.add('dragging');
    render();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isPanning) {
    panX = e.clientX - panStartX;
    panY = e.clientY - panStartY;
    updateCanvasTransform();
    return;
  }

  if (isDraggingHeightGuide) {
    // Use screen-space delta for smooth, zoom-independent dragging
    const rect = container.getBoundingClientRect();
    const screenY = e.clientY - rect.top;
    const screenDelta = heightGuideStartY - screenY;
    // Scale: 1 screen pixel = 0.5 sprite-space units for fine control
    const spriteDelta = screenDelta * 0.5;
    heightOffset = Math.max(1, Math.min(400, heightGuideStartOffset + spriteDelta));
    heightOffsetSlider.value = Math.round(heightOffset);
    heightOffsetVal.textContent = Math.round(heightOffset);
    render();
    return;
  }

  if (isDraggingPoint >= 0) {
    const { x, y } = canvasCoords(e);
    controlPoints[isDraggingPoint].x = x;
    controlPoints[isDraggingPoint].y = y;
    render();
  }

  // Update cursor when hovering over height guide
  if (isDraggingPoint < 0 && !isPanning && showHeightGuide) {
    const { x, y } = canvasCoords(e);
    if (isNearHeightGuide(x, y)) {
      canvas.style.cursor = 'ns-resize';
    } else if (!spaceHeld) {
      canvas.style.cursor = 'crosshair';
    }
  }
});

canvas.addEventListener('mouseup', () => {
  if (isPanning) {
    isPanning = false;
    canvas.classList.remove('dragging');
    return;
  }
  if (isDraggingHeightGuide) {
    isDraggingHeightGuide = false;
    canvas.classList.remove('dragging');
    canvas.style.cursor = 'crosshair';
    saveAll();
    return;
  }
  if (isDraggingPoint >= 0) {
    isDraggingPoint = -1;
    canvas.classList.remove('dragging');
    saveAll();
  }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

// Zoom
container.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = container.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  zoom = Math.max(0.05, Math.min(3, zoom * delta));

  // Zoom toward mouse position
  panX = mx - (mx - panX) * (zoom / oldZoom);
  panY = my - (my - panY) * (zoom / oldZoom);

  updateCanvasTransform();
}, { passive: false });

// Space for pan
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !e.repeat) {
    spaceHeld = true;
    canvas.style.cursor = 'grab';
    e.preventDefault();
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space') {
    spaceHeld = false;
    canvas.style.cursor = 'crosshair';
  }
});

// ── Tab Button Handlers ──
function initTabGroup(selector, callback) {
  const btns = document.querySelectorAll(selector);
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      btns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      callback(btn);
    });
  });
}

initTabGroup('[data-body]', (btn) => {
  const seed = snapshotCurrentPath();
  currentBody = btn.dataset.body;
  restorePath(seed);
});
initTabGroup('[data-tail]', (btn) => {
  const seed = snapshotCurrentPath();
  currentTail = btn.dataset.tail;
  restorePath(seed);
});
initTabGroup('[data-length]', (btn) => {
  const seed = snapshotCurrentPath();
  currentLength = btn.dataset.length;
  restorePath(seed);
});
initTabGroup('[data-spine]', (btn) => {
  currentSpine = btn.dataset.spine;
  render();
});
initTabGroup('[data-height]', (btn) => {
  currentHeight = btn.dataset.height;
  render();
});

// ── Slider Handlers ──
spineCountSlider.addEventListener('input', () => {
  spineCount = parseInt(spineCountSlider.value);
  spineCountVal.textContent = spineCount;
  render();
});
spineCountSlider.addEventListener('change', saveAll);

spineSpacingSlider.addEventListener('input', () => {
  spineSpacing = parseFloat(spineSpacingSlider.value);
  spineSpacingVal.textContent = spineSpacing.toFixed(2);
  render();
});
spineSpacingSlider.addEventListener('change', saveAll);

spineScaleSlider.addEventListener('input', () => {
  spineScale = parseFloat(spineScaleSlider.value);
  spineScaleVal.textContent = spineScale.toFixed(2);
  render();
});
spineScaleSlider.addEventListener('change', saveAll);

heightOffsetSlider.addEventListener('input', () => {
  heightOffset = parseInt(heightOffsetSlider.value);
  heightOffsetVal.textContent = heightOffset;
  render();
});
heightOffsetSlider.addEventListener('change', saveAll);

showHeightGuideCheckbox.addEventListener('change', () => {
  showHeightGuide = showHeightGuideCheckbox.checked;
  render();
});

// ── Override Handlers ──
overrideAngle.addEventListener('input', () => {
  if (selectedSpineIdx < 0) return;
  if (!perSpineOverrides[selectedSpineIdx]) perSpineOverrides[selectedSpineIdx] = {};
  perSpineOverrides[selectedSpineIdx].angleDeg = parseFloat(overrideAngle.value) || 0;
  render();
});
overrideAngle.addEventListener('change', saveAll);

overrideScale.addEventListener('input', () => {
  if (selectedSpineIdx < 0) return;
  if (!perSpineOverrides[selectedSpineIdx]) perSpineOverrides[selectedSpineIdx] = {};
  perSpineOverrides[selectedSpineIdx].scale = parseFloat(overrideScale.value) || 1.0;
  render();
});
overrideScale.addEventListener('change', saveAll);

document.getElementById('btn-reset-angle').addEventListener('click', () => {
  if (selectedSpineIdx < 0) return;
  if (perSpineOverrides[selectedSpineIdx]) {
    delete perSpineOverrides[selectedSpineIdx].angleDeg;
    if (Object.keys(perSpineOverrides[selectedSpineIdx]).length === 0) {
      delete perSpineOverrides[selectedSpineIdx];
    }
  }
  render();
  saveAll();
});

document.getElementById('btn-reset-scale').addEventListener('click', () => {
  if (selectedSpineIdx < 0) return;
  if (perSpineOverrides[selectedSpineIdx]) {
    delete perSpineOverrides[selectedSpineIdx].scale;
    if (Object.keys(perSpineOverrides[selectedSpineIdx]).length === 0) {
      delete perSpineOverrides[selectedSpineIdx];
    }
  }
  render();
  saveAll();
});

// ── Action Buttons ──
document.getElementById('btn-clear-path').addEventListener('click', () => {
  controlPoints = [];
  perSpineOverrides = {};
  selectedSpineIdx = -1;
  overridePanel.style.display = 'none';
  render();
  saveAll();
});

document.getElementById('btn-save').addEventListener('click', () => {
  saveAll();
  const btn = document.getElementById('btn-save');
  btn.textContent = 'Saved!';
  setTimeout(() => { btn.textContent = 'Save'; }, 1200);
});

document.getElementById('btn-copy-anchors').addEventListener('click', () => {
  const positions = computeSpinePositions();
  const key = currentPathKey();
  const lines = positions.map(pos =>
    `  'spine_${pos.idx}:${key}': { x: ${Math.round(pos.x)}, y: ${Math.round(pos.y)}, rot: ${pos.angleDeg.toFixed(1)} },`
  );
  navigator.clipboard.writeText(lines.join('\n'));
  const btn = document.getElementById('btn-copy-anchors');
  btn.textContent = 'Copied!';
  setTimeout(() => { btn.textContent = 'Copy Anchors'; }, 1200);
});

document.getElementById('btn-copy-curve').addEventListener('click', () => {
  const curveData = {
    key: currentPathKey(),
    controlPoints: controlPoints.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
    spineCount, spineSpacing, spineScale, heightOffset,
    perSpineOverrides: { ...perSpineOverrides },
    spineType: currentSpine,
    spineHeight: currentHeight,
  };
  navigator.clipboard.writeText(JSON.stringify(curveData, null, 2));
  const btn = document.getElementById('btn-copy-curve');
  btn.textContent = 'Copied!';
  setTimeout(() => { btn.textContent = 'Copy Curve'; }, 1200);
});

// ── Init ──
restorePath();
</script>
</body>
</html>
